{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"Pages/","title":"Welcome to MAutils Pro","text":"<p>MAutils Pro is a powerful, modular Java library designed to streamline FRC robot development. Built with performance, flexibility, and ease of use in mind, it offers a wide range of features including: <ul> <li>An intuitive state machine system  </li> <li>Robot-wide logging and Dashboard intigration</li> <li>Fuully featured swerve code  </li> <li>Default self-testing subsystems </li> <li>...and much more!</li> </ul> <p>MAutils Pro reduces boilerplate and promotes clean, scalable design\u2014helping teams focus more on strategy and performance than repetitive implementation details.</p> <p>This is the scouting app made by Makers Assemble 5951</p>"},{"location":"Pages/controllers/","title":"Controller Support in MAutils","text":"<p>MAutils provides a unified and abstracted interface for game controllers, allowing seamless integration with multiple types of gamepads (e.g. PS5 and Xbox) without changing your robot control code.</p> <p>All controllers extend the <code>MAController</code> abstract class, which defines a consistent set of button mappings and input methods.</p>"},{"location":"Pages/controllers/#supported-controllers","title":"Supported Controllers","text":"<ul> <li>PS5 DualSense \u2013 <code>PS5MAController</code></li> <li>Xbox Series Controller \u2013 <code>XboxMAController</code></li> </ul> <p>Both use the same interface:</p> <pre><code>MAController controller = new PS5MAController(0);\n// Or:\ncontroller = new XboxMAController(0);\n</code></pre>"},{"location":"Pages/controllers/#button-layout-unified-naming","title":"Button Layout (Unified Naming)","text":"<p>MAutils uses generic method names so your robot code works consistently across all supported controllers.</p> PS5Xbox <p></p> <p></p> <p>Example:</p> <pre><code>controller.getActionsUp(); // Maps to the Triangle button on PS5 or the Y button on Xbox\n</code></pre>"},{"location":"Pages/controllers/#deadband-handling","title":"Deadband Handling","text":"<p>Each controller has a calibrated deadband value to help eliminate small input noise:</p> Controller Default Deadband PS5 <code>0.1</code> Xbox <code>0.3</code> <p>To apply deadband filtering:</p> <pre><code>double value = controller.withDeadbound(rawValue);         // Uses default for controller\ndouble custom = controller.withDeadbound(rawValue, 0.2);   // Uses custom value\n</code></pre> <p>This can be applied to stick positions or trigger axes as needed.</p>"},{"location":"Pages/controllers/#rumble-support","title":"Rumble Support","text":"<p>The <code>setRumble()</code> method allows vibration feedback, but note:</p> <ul> <li>Xbox controllers support rumble natively through the Driver Station.</li> <li>PS5 controllers do not support rumble reliably unless emulated as Xbox controllers, which is not recommended due to inconsistent behavior.</li> </ul> <pre><code>controller.setRumble(0.5); // Activate rumble at 50% power\n</code></pre>"},{"location":"Pages/controllers/#controller-logging","title":"Controller Logging","text":"<p>For diagnostics or special use cases, you can log controller input to NetworkTables:</p> <pre><code>controller.log();\n</code></pre> <p>This records the current state of buttons and axes to:</p> <pre><code>/Controllers/{port}/[ButtonName]\n</code></pre> <p>Useful for testing in Shuffleboard or AdvantageScope.</p>"},{"location":"Pages/controllers/#sample-implementation","title":"Sample Implementation","text":"<pre><code>@Override\npublic void teleopPeriodic() {\n    if (controller.getL1()) intake.run();\n    if (controller.getR2()) shooter.shoot();\n\n    drivetrain.arcadeDrive(\n        controller.withDeadbound(controller.getLeftY()),\n        controller.withDeadbound(controller.getRightX())\n    );\n\n    controller.log();\n}\n</code></pre>"},{"location":"Pages/key_features/","title":"\ud83c\udfaf Here are some of MAutils Key Features","text":""},{"location":"Pages/key_features/#flexible-state-machine-architecture","title":"\ud83e\udde0 Flexible State Machine Architecture","text":"<ul> <li>Coordinate multiple subsystems easily  </li> <li>Easy to use, debug, and write </li> <li>Perfect for autonomous or multi-stage tasks</li> </ul>"},{"location":"Pages/key_features/#default-subsystems-with-zero-code-setup","title":"\u2699\ufe0f Default Subsystems with Zero Code Setup","text":"<ul> <li>Advanced, configurable subsystems with Zero Code Setup</li> <li>Built-in self-tests and diagnostics  </li> <li>Automatic failure detection </li> </ul>"},{"location":"Pages/key_features/#fully-featured-plug-and-play-swerve-support","title":"\u2705 Fully Featured, Plug-and-Play Swerve Support","text":"<ul> <li>High-frequency odometry updates  </li> <li>Skid and collision detection  </li> <li>Full simulation support via MapleSim</li> <li>PathPlanner integration  </li> <li>Sevral Control modes:  Auto-align, Angle adjust, Advanced Field-relative and Robot-relative drive, and so much more</li> </ul>"},{"location":"Pages/key_features/#comprehensive-logging-system","title":"\ud83e\udeb5 Comprehensive Logging System","text":"<ul> <li>Log values, events, and system health  </li> <li>Useful for both live debugging and post-match analysis</li> </ul>"},{"location":"Pages/key_features/#dashboard-integration","title":"\ud83d\udcca Dashboard Integration","text":"<ul> <li>Tune constants (e.g. PID) in real time  </li> <li>Advanced Auto Ruutine Chooser</li> <li>Works with Elastic FRC Dashboard, Shuffleboard, and more</li> </ul>"},{"location":"Pages/logger/","title":"MALog Logging System","text":"<p>MALog is the unified logging utility in MAutils. It provides an interface for real-time logging to NetworkTables, as well as persistent storage via DataLogManager.</p> <p>The logger records all NetworkTables data, including values logged via MALog, joystick states, vision coprocessor output, and FMS data.</p>"},{"location":"Pages/logger/#initialization","title":"Initialization","text":"<p>Start the logger once at the beginning of a mode:</p> <pre><code>MALog.startLog(MALogMode.AUTO);\n// Or:\nMALog.startLog(MALogMode.TELEOP);\n</code></pre> <p>This starts data logging with a unique session ID and a timestamped filename (if not running on FMS). If using <code>DeafultRobotContainer</code>, the log is started and stopped automaticly.</p> Log naming format <p>Logs are saved using the format: <code>MALog_Mode_SessionID_Timestamp</code>. - Mode corresponds to the robot's current mode (<code>AUTO</code>, <code>TELEOP</code>, <code>TEST</code>). - SessionID is a unique, persistent number that increments on each run (stored in <code>/home/lvuser/malog/lastLogID.txt</code>). Use <code>resetID()</code> to reset it manually. - Timestamp follows the format <code>yyyy-MM-dd_HH-mm-ss</code>.</p> <p>Example: <pre><code>MALog_Teleop_0047_2025-11-02_16-22-17\n</code></pre></p> <p>To stop logging:</p> <pre><code>MALog.stopLog();\n</code></pre>"},{"location":"Pages/logger/#logging-basic-values","title":"Logging Basic Values","text":"<p>You can log values using a string key:</p> <pre><code>MALog.log(\"/Subsystems/Arm/Arm Angle\", 45.0);\nMALog.log(\"/Subsystems/Swerve/Is Aligned\", true);\nMALog.log(\"/RobotControl/Mode\", \"AUTO\");\n</code></pre> <p>Or with suppliers (evaluated at runtime):</p> <pre><code>MALog.log(\"/Pneumatics/Pressure\", () -&gt; compressor.getPressure());\n</code></pre>"},{"location":"Pages/logger/#logging-advanced-types","title":"Logging Advanced Types","text":""},{"location":"Pages/logger/#pose2d","title":"Pose2d","text":"<pre><code>MALog.log(\"Odometry/Pose2d\", drivetrain.getPose());\n</code></pre>"},{"location":"Pages/logger/#pose3d","title":"Pose3d","text":"<pre><code>MALog.log(\"Odometry/Pose3d\", camera.getPose());\n</code></pre>"},{"location":"Pages/logger/#pose3d_1","title":"Pose3d[]","text":"<pre><code>MALog.log(\"Vision/Targets\", allDetectedTags);\n</code></pre>"},{"location":"Pages/logger/#swervemodulestate","title":"SwerveModuleState[]","text":"<pre><code>MALog.logSwerveModuleStates(\"Drive/Modules\", swerve.getModuleStates());\n</code></pre>"},{"location":"Pages/logger/#chassisspeeds","title":"ChassisSpeeds","text":"<pre><code>MALog.log(\"Drive/ChassisSpeeds\", kinematics.toChassisSpeeds());\n</code></pre> <p>All of these publish to NetworkTables under the <code>MALog/</code> namespace.</p>"},{"location":"Pages/logger/#getting-logged-values","title":"Getting Logged Values","text":"<p>You can retrieve numeric values from NetworkTables:</p> <pre><code>double shooterRPM = MALog.getEntry(\"Shooter/RPM\").getDouble(0);\n</code></pre>"},{"location":"Pages/logger/#flags-and-status","title":"Flags and Status","text":"<p>Use <code>flag()</code> to mark specific events in logs:</p> <pre><code>MALog.flag(\"Driver Flag\");\n</code></pre> <p>You can view the flag field in a graph to easily locate these events.</p> Using flags during driver practice <p>If the driver encounters a bug or something feels off, they can press a controller button mapped to <code>MALog.flag()</code>. This creates a visible marker in the log, allowing the software team to easily investigate it afterward.</p> <p>Indicates the status of the robot, other parts of MAutils use this field so its mostly reserved for library use.</p> <pre><code>MALog.addStatus(\"Self Testing\");\n</code></pre>"},{"location":"Pages/logger/#example","title":"Example","text":"<pre><code>@Override\npublic void robotInit() {\n    MALog.startLog(MALogMode.TELEOP);\n}\n\n@Override\npublic void teleopPeriodic() {\n    MALog.log(\"Shooter/Velocity\", shooter.getVelocity());\n    MALog.log(\"Drive/Pose2d\", drivetrain.getPose());\n    MALog.log(\"Drive/Modules\", drivetrain.getModuleStates());\n    MALog.log(\"Intake/Pressed\", intakeButton::get);\n}\n</code></pre>"},{"location":"Pages/state_machine/robot_container_methods/","title":"RobotContainer Overview","text":"<p>The <code>RobotContainer</code> class serves as the main control hub of the robot. It manages critical robot-wide functionality such as the robot state, driver/operator controllers, simulation configuration, and subsystem command coordination.</p>"},{"location":"Pages/state_machine/robot_container_methods/#controller-management","title":"Controller Management","text":"<p>The <code>RobotContainer</code> defines default controllers:</p> <ul> <li><code>driverController</code>: Defaults to a <code>PS5MAController</code> on port <code>0</code></li> <li><code>operatorController</code>: Defaults to a <code>PS5MAController</code> on port <code>1</code></li> </ul> <p>You can customize or override them:</p> <pre><code>setDriverController(new XboxMAController(1));\ngetDriverController();\n\nsetOperatorController(new PS5MAController(3));\ngetOperatorController();\n</code></pre>"},{"location":"Pages/state_machine/robot_container_methods/#simulation-configuration","title":"Simulation Configuration","text":"<p>Simulation tools can be configured using the following methods:</p> <pre><code>setSwerveDriveSimulation(SwerveDriveSimulation simulation);\n</code></pre> <p>Enables drivetrain simulation with MapleSim.</p> <pre><code>setGamePiecesList(new String[] {\"Coral\", \"Algae\"});\n</code></pre> <p>Defines the list of simulated game pieces in MapleSim.</p>"},{"location":"Pages/state_machine/robot_container_methods/#robot-state-management","title":"Robot State Management","text":"<p>The container manages the current and previous <code>RobotState</code>:</p> <pre><code>getRobotState();\ngetLastRobotState();\n\nsetRobotState(RobotState.CLIMB);\n</code></pre> <p>While <code>setRobotState()</code> can be called directly, it is generally managed by triggers and robot logic.</p>"},{"location":"Pages/state_machine/robot_container_methods/#subsystem-coordination","title":"Subsystem Coordination","text":"<p>You can register subsystem commands to be scheduled automatically:</p> <pre><code>addSystemCommand(new ArmCommand());\n</code></pre>"},{"location":"Pages/state_machine/robot_container_methods/#lifecycle-methods","title":"Lifecycle Methods","text":"<p>The <code>RobotContainer</code> also defines lifecycle methods that are called in thier corresponding methods in the <code>Robot</code> class. These calles are are already in place if you generated your project from our template. </p> <ul> <li><code>robotInit()</code></li> <li><code>robotPeriodic()</code></li> <li><code>teleopInit()</code>, <code>teleopPeriodic()</code></li> <li><code>autonomousInit()</code>, <code>autonomousPeriodic()</code></li> <li><code>testInit()</code>, <code>testPeriodic()</code></li> <li><code>simulationInit()</code>, <code>simulationPeriodic()</code></li> </ul>"},{"location":"Pages/state_machine/robot_state/","title":"RobotState Guide","text":"<p>The <code>RobotState</code> class defines the full-state of the robot, encapsulating the intended behavior of all subsystems at a given point in time (e.g. <code>INTAKE</code>, <code>PRE_SCORING</code>, <code>CLIMB</code>).</p>"},{"location":"Pages/state_machine/robot_state/#purpose","title":"Purpose","text":"<p><code>RobotState</code> objects act as high-level modes that:</p> <ul> <li>Assign specific <code>SubsystemState</code>s to each subsystem</li> <li>Optionally run custom logic when the state is entered (e.g. reset counters, print debug messages)</li> </ul>"},{"location":"Pages/state_machine/robot_state/#fields","title":"Fields","text":"<p>Each <code>RobotState</code> contains:</p> <ul> <li><code>name</code> \u2013 A <code>String</code> representing the name of the robot state (e.g. <code>INTAKE</code>, <code>CLIMB</code>)</li> <li><code>subsystemStates</code> \u2013 A collection of the <code>SubsystemState</code>s to be assigned when this state is activated</li> <li><code>onStateSet</code> \u2013 An optional <code>Runnable</code> that executes custom logic (e.g. logging, resetting variables) when the state is set</li> </ul>"},{"location":"Pages/state_machine/robot_state/#state-activation","title":"State Activation","text":"<p>To activate a robot state, call:</p> <pre><code>RobotState.setState();\n</code></pre> <p>This will:</p> <ol> <li>Run the <code>onStateSet</code> Runnable if it exists</li> <li>Set each subsystem's state </li> </ol>"},{"location":"Pages/state_machine/robot_state/#example-definition","title":"Example Definition","text":"<p>Robot states are usually defined in the <code>RobotConstants</code> class for central access:</p> RobotState Names <p>Use descriptive names like <code>PRE_SCORE</code>, <code>CLIMB</code>, or <code>SAFE_DEPLOY</code></p> <pre><code>public class RobotConstants {\n\n    public static final RobotState IDLE = new RobotState(\n        \"IDLE\",\n        IntakeConstants.IDLE,\n        GripperConstants.IDLE,\n        ArmConstants.IDLE,\n        ClimbConstants.IDLE,\n        ElevatorConstants.IDLE\n    );\n\n    public static final RobotState PRE_CLIMB = new RobotState(\n        \"PRE_CLIMB\",\n        () -&gt; { System.out.println(\"PRE_CLIMB Entered\"); },\n        IntakeConstants.IDLE,\n        GripperConstants.IDLE,\n        ArmConstants.CLMB_POS,\n        ClimbConstants.DEPLOY,\n        ElevatorConstants.CLMB_POS\n    );\n\n    public static final RobotState CLIMB = new RobotState(\n        \"CLIMB\",\n        () -&gt; { System.out.println(\"Started Climb\"); },\n        IntakeConstants.IDLE,\n        GripperConstants.IDLE,\n        ArmConstants.CLMB_POS,\n        ClimbConstants.CLIMB,\n        ElevatorConstants.CLMB_POS\n    );\n}\n</code></pre> <p>Each robot state manages the coordination of all major mechanisms for a given scenario.</p>"},{"location":"Pages/state_machine/robot_state_triggers/","title":"Robot State Triggers","text":"<p>Robot state triggers are responsible for changing the current <code>RobotState</code> based on sensor input, subsystem conditions, or driver/operator commands.</p> <p>This system helps manage transitions between complex behaviors (e.g. INTAKE \u2794 IDLE \u2794 SCORING) in a clear and modular way.</p>"},{"location":"Pages/state_machine/robot_state_triggers/#trigger-overview","title":"Trigger Overview","text":"<p>Each <code>RobotState</code> can have:</p> <ul> <li>Enter triggers: Conditions to switch into a state</li> <li>Exit triggers: Conditions to switch out of a state</li> </ul>"},{"location":"Pages/state_machine/robot_state_triggers/#example","title":"Example","text":"<pre><code>// Enter INTAKE state\n!SuperStructure.hasGamePiece() &amp;&amp; getDriverController().getL1()\n\n// Exit INTAKE and enter IDLE when game piece is detected\ngetRobotState() == RobotConstants.INTAKE &amp;&amp; SuperStructure.hasGamePiece()\n</code></pre>"},{"location":"Pages/state_machine/robot_state_triggers/#statetrigger-class","title":"StateTrigger Class","text":"<p>To simplify writing these conditions, MAutils provides the <code>StateTrigger</code> (commonly used via a static function <code>T(...)</code>).</p>"},{"location":"Pages/state_machine/robot_state_triggers/#syntax","title":"Syntax","text":"<pre><code>T(BooleanSupplier condition, RobotState stateToSet).build();\n</code></pre> <p>You can also chain additional context conditions:</p> <pre><code>.withInRobotState(RobotState robotInState)\n.withRobotMode(RobotMode mode)\n</code></pre> <p>These allow a trigger to only apply in specific robot states or match certain robot modes (e.g. TELEOP, AUTO).</p>"},{"location":"Pages/state_machine/robot_state_triggers/#full-example","title":"Full Example","text":"<pre><code>// Transition to INTAKE if we don't have a game piece and L1 is pressed\nT(() -&gt; !SuperStructure.hasGamePiece() &amp;&amp; getDriverController().getL1(), RobotConstants.INTAKE)\n    .build();\n\n// Transition to IDLE once a game piece is acquired (but only if we're currently in INTAKE)\nT(() -&gt; SuperStructure.hasGamePiece(), RobotConstants.IDLE)\n    .withInRobotState(RobotConstants.INTAKE)\n    .build();\n</code></pre>"},{"location":"Pages/state_machine/state_machine_structure.md/","title":"State Machine Structure","text":"<p>MAutils provides an advanced, flexible, and easy-to-use state machine structure designed to manage robot behavior at both the subsystem and full-system levels.</p> <p>This architecture is built around clear modular components:</p>"},{"location":"Pages/state_machine/state_machine_structure.md/#flow-diagram","title":"Flow Diagram","text":"<pre><code>graph LR\n  A[Driver Inputs, Sensors, Odometry Data, Vision Data ...] --&gt; B[StateTriggers, Decide the current RobotState based on the data];\n  B --&gt; C[RobotState sets all of the subsystems to thier matching SubsystemStates];\n  C --&gt; D[StateSubsystem, holds the system's current SubsystemStates, Calculates CAN_MOVE and decides SystemMode based on inputs ];\n  A --&gt; D;\n  D --&gt; E[SystemCommand, runs the system based on its current SubsystemState, CAN_MOVE and SystemMode];</code></pre>"},{"location":"Pages/state_machine/state_machine_structure.md/#key-components","title":"Key Components","text":""},{"location":"Pages/state_machine/state_machine_structure.md/#robotcontainer-extends-defaultrobotcontainer","title":"<code>RobotContainer</code> (extends <code>DefaultRobotContainer</code>)","text":"<ul> <li>Central brain for the robot.</li> <li>Manages the current <code>RobotState</code>.</li> <li>Handles:<ul> <li>State transitions and logic (StateTriggers)</li> <li>Controllers input</li> <li>Logging setup</li> <li>Simulation configuration </li> </ul> </li> </ul>"},{"location":"Pages/state_machine/state_machine_structure.md/#subsystem-extends-statesubsystem-or-one-of-the-defaultsubsystems","title":"<code>Subsystem</code> (extends <code>StateSubsystem</code> or one of the <code>DefaultSubsystems</code>)","text":"<ul> <li>Encapsulates the physical behavior and control logic for a single subsystem (e.g. Arm, Shooter, Intake).</li> <li>Responsible for:<ul> <li>Holding the current <code>SubsystemState</code> of the system</li> <li>Holding the current <code>SystemMode</code> (e.g. MANUAL, AUTOMATIC)</li> <li>Handling data logging, health checks, and CAN_MOVE logic</li> <li>Configuring and runing Self Tests</li> </ul> </li> </ul>"},{"location":"Pages/state_machine/state_machine_structure.md/#subsystemcommand-extends-subsystemcommand","title":"<code>SubsystemCommand</code> (extends <code>SubsystemCommand</code>)","text":"<ul> <li>A command responsible for running the subsystem based on its <code>SubsystemState</code>, <code>SystemMode</code> and <code>CAN_MOVE()</code></li> <li>Defines:<ul> <li>What the subsystem should do in each of its states</li> <li>What happens in manual mode</li> <li>What happens when movement is disabled</li> </ul> </li> </ul>"},{"location":"Pages/state_machine/state_machine_structure.md/#subsystemstate","title":"<code>SubsystemState</code>","text":"<ul> <li>Represents a specific state for a single subsystem.</li> <li>Assigned to a <code>StateSubsystem</code></li> <li>Can be reused across multiple robot states</li> </ul>"},{"location":"Pages/state_machine/state_machine_structure.md/#robotstate","title":"<code>RobotState</code>","text":"<ul> <li>Represents the state of the full robot.</li> <li>Holds a <code>SubsystemState</code> for each subsystem.</li> </ul>"},{"location":"Pages/state_machine/state_subsystems/","title":"StateSubsystem Overview","text":"<p><code>StateSubsystem</code> is a base class in MAutils designed to represent robot subsystems that operate in distinct states. It simplifies state-based control logic by associating the subsystem with a <code>SubsystemState</code> and <code>SystemMode</code>, and logs system behavior through MALog.</p>"},{"location":"Pages/state_machine/state_subsystems/#constructor","title":"Constructor","text":"<pre><code>public StateSubsystem(String name, SubsystemState... subsystemStates)\n</code></pre> <ul> <li>name \u2013 A unique name for this subsystem (used in logging)</li> <li>subsystemStates \u2013 The set of states this subsystem can operate in; each state is initialized with a reference to this subsystem</li> </ul>"},{"location":"Pages/state_machine/state_subsystems/#fields-and-structure","title":"Fields and Structure","text":"<p>Each <code>StateSubsystem</code> includes the following fields:</p> <ul> <li><code>SubsystemState currentState</code> \u2013 The current state of the subsystem</li> <li><code>SystemMode systemMode</code> \u2013 The system control mode (<code>AUTOMATIC</code>, <code>MANUAL</code>, etc.)</li> <li><code>String subsystemName</code> \u2013 A unique name for this subsystem, used in logging and dashboards</li> </ul>"},{"location":"Pages/state_machine/state_subsystems/#core-methods","title":"Core Methods","text":"<p>These are the primary control methods available in a <code>StateSubsystem</code>:</p> <ul> <li> <p><code>setState(SubsystemState state)</code>   Sets the subsystem\u2019s current state.</p> </li> <li> <p><code>getCurrentState()</code>   Returns the currently active <code>SubsystemState</code>.</p> </li> <li> <p><code>setSystemMode(SystemMode mode)</code>   Sets the system's operational mode.</p> </li> <li> <p><code>getSystemMode()</code>   Returns the current <code>SystemMode</code>.</p> </li> <li> <p><code>CAN_MOVE()</code>   Returns <code>true</code> or <code>false</code> based on whether the subsystem is allowed to operate. Override this in your subclass to implement custom logic.</p> </li> <li> <p><code>getSelfTest()</code>   Returns a <code>Command</code> that runs a self-test. This is intended to be overridden in each subsystem to provide meaningful diagnostics. See the SelfTest documentation for more details.</p> </li> <li> <p><code>periodic()</code>   Called once per scheduler loop. This method includes automatic logging of the subsystem state.</p> </li> </ul> Default Logging Behavior <p>The following values are automatically logged every cycle to NetworkTables:</p> <pre><code>- `/RobotControl/{subsystemName}/Current State`\n- `/RobotControl/{subsystemName}/System Function State`\n- `/RobotControl/{subsystemName}/Can Move`\n</code></pre>"},{"location":"Pages/state_machine/state_subsystems/#instantiating-a-statesubsystem","title":"Instantiating a StateSubsystem","text":"<p>When constructing your <code>StateSubsystem</code>, you must provide a name and optionally pass in all the states the subsystem can use. Each state will automatically link back to this subsystem.</p> <pre><code>public class Arm extends StateSubsystem {\n\n    public Arm() {\n        super(\"Arm\",\n            ArmConstants.IDLE,\n            ArmConstants.INTAKE,\n            ArmConstants.EXTENDED,\n            ArmConstants.RETRACTED,\n            ArmConstants.FEEDER\n        );\n    }\n}\n</code></pre> <p>This design ensures all your subsystem states are registered correctly and the name is consistent across logs and NT entries.</p>"},{"location":"Pages/state_machine/subsystem_command/","title":"Subsystem Command","text":"<p>The <code>SubsystemCommand</code> defines the behavior of a subsystem in different operational scenarios. It centralizes logic for automatic control, manual override, and safety conditions when the subsystem cannot move.</p> <p>This pattern ensures each subsystem consistently follows its intended behavior without duplicating control logic across robot states.</p>"},{"location":"Pages/state_machine/subsystem_command/#command-structure","title":"Command Structure","text":"<p>Each <code>SubsystemCommand</code> must implement the following three methods:</p>"},{"location":"Pages/state_machine/subsystem_command/#1-automatic","title":"1. <code>Automatic()</code>","text":"<p>Handles autonomous and automatic robot modes. Typically structured with a switch statement based on the current state:</p> <pre><code>public void Automatic() {\n    switch (arm.getCurrentState().stateName) {\n        case \"IDLE\":\n            arm.setVoltage(arm.getFeedForward());\n            break;\n        case \"INTAKE\":\n            arm.setPosition(ArmConstants.INTAKE_POS);\n            break;\n        case \"SCORING \":\n            arm.setPosition(SuperStructure.getScoringLevel().getArmPos());\n            break;\n        case \"BALL_ANGLE\":\n            arm.setPosition(SuperStructure.getBallRemovingLevel().getArmPos());\n            break;\n    }\n}\n</code></pre>"},{"location":"Pages/state_machine/subsystem_command/#2-manual","title":"2. <code>Manual()</code>","text":"<p>Typically used to apply input from the operator controller:</p> <pre><code>public void Manual() {\n    arm.setVoltage(\n        RobotContainer.getOperatorController().getLeftY() * ArmConstants.MANUAL_VOLTAGE_LIMIT\n    );\n}\n</code></pre>"},{"location":"Pages/state_machine/subsystem_command/#3-cantmove","title":"3. <code>CantMove()</code>","text":"<p>Called when <code>CAN_MOVE()</code> returns <code>false</code>. This prevents unsafe movement:</p> <pre><code>public void CantMove() {\n    arm.setVoltage(arm.getFeedForward());\n}\n</code></pre> <p>In most systems, this simply applies a feedforward hold or zero voltage.</p>"},{"location":"Pages/state_machine/subsystem_command/#example-full-armcommand","title":"Example: Full ArmCommand","text":"<pre><code>package frc.robot.commands;\n\nimport com.MAutils.RobotControl.SubsystemCommand;\n\nimport frc.robot.RobotContainer;\nimport frc.robot.subsystems.Arm.Arm;\n\npublic class ArmCommand extends SubsystemCommand {\n    private static Arm arm = RobotContainer.arm;\n\n    public ArmCommand() {\n        super(arm);\n    }\n\n    public void Automatic() {\n    switch (arm.getCurrentState().stateName) {\n        case \"IDLE\":\n            arm.setVoltage(arm.getFeedForward());\n            break;\n        case \"INTAKE\":\n            arm.setPosition(ArmConstants.INTAKE_POS);\n            break;\n        case \"SCORING \":\n            arm.setPosition(SuperStructure.getScoringLevel().getArmPos());\n            break;\n        case \"BALL_ANGLE\":\n            arm.setPosition(SuperStructure.getBallRemovingLevel().getArmPos());\n            break;\n        }\n    }\n\n    public void Manual() {\n        arm.setVoltage(\n            RobotContainer.getOperatorController().getLeftY() * ArmConstants.MANUAL_VOLTAGE_LIMIT);\n    }\n\n    public void CantMove() {\n        arm.setVoltage(arm.getFeedForward());\n    }\n}\n</code></pre>"},{"location":"Pages/state_machine/subsystem_command/#autonomous-and-test-modes","title":"Autonomous and Test Modes","text":"<ul> <li> <p>Autonomous:  By default, the command executes the Automatic() method during autonomous mode. You can override this  method if you require a different behavior in auto.</p> </li> <li> <p>Test: In test mode, no logic is run by default. This prevents interference with any self-test commands being executed. You may override this behavior by defining a custom Test() method in your command if needed.</p> </li> </ul>"},{"location":"Pages/state_machine/subsystem_logic/","title":"Subsystem Logic: <code>CAN_MOVE()</code>","text":"<p>Each subsystem in MAutils should override the <code>CAN_MOVE()</code> method to define whether the system is currently allowed to move. This mechanism is essential for safe coordination between multiple subsystems and simplifies complex inter-subsystem logic.</p>"},{"location":"Pages/state_machine/subsystem_logic/#purpose-of-can_move","title":"Purpose of <code>CAN_MOVE()</code>","text":"<p>The <code>CAN_MOVE()</code> method returns a boolean that indicates whether the subsystem can safely perform movement-related actions.</p> <p>It is used to:</p> <ul> <li>Prevent collisions between subsystems</li> <li>Coordinate manipulator safety (e.g., arm and elevator)</li> <li>Respect physical limits (e.g., soft stops, mechanical ranges)</li> <li>Detect fault states like high current draw</li> </ul> <p>Always tailor <code>CAN_MOVE()</code> to the specific logic and safety requirements of each subsystem.</p>"},{"location":"Pages/state_machine/subsystem_logic/#recommended-use-cases","title":"Recommended Use Cases","text":""},{"location":"Pages/state_machine/subsystem_logic/#collision-avoidance","title":"Collision Avoidance","text":"<p>Check that your subsystem won\u2019t collide with another.</p>"},{"location":"Pages/state_machine/subsystem_logic/#game-piece-safety","title":"Game Piece Safety","text":"<p>Ensure game pieces are secured or released only under valid conditions.</p>"},{"location":"Pages/state_machine/subsystem_logic/#spatial-boundaries","title":"Spatial Boundaries","text":"<p>Avoid exceeding minimum or maximum mechanical limits.</p>"},{"location":"Pages/state_machine/subsystem_logic/#current-monitoring","title":"Current Monitoring","text":"<p>Stop motion if current indicates a jam or stall.</p>"},{"location":"Pages/state_machine/subsystem_logic/#recommended-pattern-for-manipulator-subsystems","title":"Recommended Pattern for Manipulator Subsystems","text":"<p>For systems like intakes, grippers, shooters, or transfers, we recommend having per-robot-state checks:</p> <pre><code>public boolean IntakeCanMove() {\n    return RobotContainer.getRobotState() == RobotConstants.INTAKE\n        &amp;&amp; Elevator.atPoint()\n        &amp;&amp; Arm.atPoint()\n        &amp;&amp; !gamePieceSensor.get();\n}\n\npublic boolean ScoringCanMove() {\n    return RobotContainer.getRobotState() == RobotConstants.SCORING\n        &amp;&amp; Elevator.atPoint()\n        &amp;&amp; Arm.atPoint()\n        &amp;&amp; gamePieceSensor.get()\n        &amp;&amp; Swerve.atPosition();\n}\n\n@Override\npublic boolean CAN_MOVE() {\n    return IntakeCanMove() || ScoringCanMove();\n}\n</code></pre> <p>This pattern ensures each robot state has its own movement condition logic, improving clarity and safety.</p>"},{"location":"Pages/state_machine/subsystem_logic/#example-for-motion-constraints-elevator-arm-etc","title":"Example for Motion Constraints (Elevator, Arm, etc.)","text":"<p>For subsystems that move within physical bounds:</p> <pre><code>@Override\npublic boolean CAN_MOVE() {\n    return getPosition() &lt; ElevatorConstants.MAX_POSE\n        &amp;&amp; getPosition() &gt; ElevatorConstants.MIN_POSE\n        &amp;&amp; Math.abs(getCurrent()) &lt; 60;\n}\n</code></pre> <p>This prevents damage from over-extension and detects jams based on current draw.</p>"},{"location":"Pages/state_machine/subsystem_states/","title":"SubsystemState","text":"<p>The <code>SubsystemState</code> class represents a specific state of a given subsystem.</p>"},{"location":"Pages/state_machine/subsystem_states/#structure","title":"Structure","text":"<p>Each subsystem has its own collection of <code>SubsystemState</code> objects, which are linked to the subsystem they belong to.</p> <p>Every <code>SubsystemState</code> contains:</p> <ul> <li><code>stateName</code> \u2014 The name of the state.</li> <li><code>subsystem</code> \u2014 The <code>StateSubsystem</code> it is assigned to.</li> </ul> <p>A <code>SubsystemState</code> can be created in two ways:</p> <pre><code>public static final SubsystemState PRE_SCORING = new SubsystemState(\"PRE_SCORING\", arm);\n</code></pre> <p>or by assigning the subsystem later:</p> <pre><code>public static final SubsystemState PRE_SCORING = new SubsystemState(\"PRE_SCORING\");\nPRE_SCORING.setSubsystem(arm);\n</code></pre> <p>\u26a0\ufe0f Warning: Always ensure the <code>stateName</code> matches the variable name. This ensures consistency and improves readability when debugging or logging.</p> SubsystemState Names <p>We recommand to name your subsystem states based on the robot state they will be used on or a descriptive actions, for example \"INTAKE\" \"PRE_SCORING\" \"DEPLOY_CLIMB\" \"CLOSE_CLIMB\" and so on!</p>"},{"location":"Pages/state_machine/subsystem_states/#recommended-usage","title":"Recommended Usage","text":"<p>It is recommended to define all your states in a constants file like this:</p> <pre><code>public class ArmConstants {\n    //Other Constants...\n\n    public static final SubsystemState IDLE = new SubsystemState(\"IDLE\");\n    public static final SubsystemState INTAKE = new SubsystemState(\"INTAKE\");\n    public static final SubsystemState L1_SCORING = new SubsystemState(\"L1_SCORING\");\n    public static final SubsystemState PRE_SCORING = new SubsystemState(\"PRE_SCORING\");\n}\n</code></pre> <p>Then, pass those states into the <code>StateSubsystem</code> constructor to automatically bind them to the subsystem:</p> <pre><code>public class Arm extends StateSubsystem {\n    public Arm() {\n        super(\"Arm\",\n            ArmConstants.IDLE,\n            ArmConstants.INTAKE,\n            ArmConstants.L1_SCORING,\n            ArmConstants.PRE_SCORING\n        );\n    }\n}\n</code></pre> <p>This makes the state machine setup cleaner and ensures every state knows which subsystem it belongs to.</p>"},{"location":"Pages/state_machine/subsystems_state_machine/","title":"Subsystems Structure","text":""},{"location":"Pages/state_machine/subsystems_state_machine/#file-structure-for-subsystems","title":"File Structure for Subsystems","text":"<p>MAutils encourages a clean, modular folder and file structure to organize subsystem logic, constants, and commands.</p> <p>Each subsystem resides in its own folder and contains two core files:</p> <ul> <li>A main subsystem class (e.g., <code>Intake.java</code>, <code>Arm.java</code>)</li> <li>A constants file (e.g., <code>IntakeConstants.java</code>, <code>GripperConstants.java</code>)</li> <li>A folder that containse IOs and other heleper class (If needed) </li> </ul> <p>This structure makes it easy to locate physical configurations, states, and PID parameters for each component.</p>"},{"location":"Pages/state_machine/subsystems_state_machine/#subsystem-folder-layout","title":"Subsystem Folder Layout","text":"<pre><code>/robot/Subsystems\n  \u2514\u2500\u2500 Intake/\n        \u251c\u2500\u2500 IOs (If needed)\n        |    \u251c\u2500\u2500 IntakeIOReal.java\n             \u2514\u2500\u2500 IntakeIOSim.java\n        \u251c\u2500\u2500 Intake.java\n        \u2514\u2500\u2500 IntakeConstants.java\n\n  \u2514\u2500\u2500 Arm/\n        \u251c\u2500\u2500 Arm.java\n        \u2514\u2500\u2500 ArmConstants.java\n</code></pre>"},{"location":"Pages/state_machine/subsystems_state_machine/#constants-file-purpose","title":"Constants File Purpose","text":"<p>The <code>*Constants.java</code> file should include:</p> <ul> <li>Physical dimensions (gear ratios, encoder ticks, etc.)</li> <li>PID tuning values</li> <li>Static configuration parameters</li> <li>The <code>SubsystemState</code> definitions used by that subsystem</li> </ul> <p>Example (partial):</p> <pre><code>public class ArmConstants {\n    public static final double kP = 0.07;\n    public static final double ARM_LENGTH = 0.48;\n\n    public static final SubsystemState IDLE = new SubsystemState(\"IDLE\");\n    public static final SubsystemState EXTENDED = new SubsystemState(\"EXTENDED\");\n}\n</code></pre>"},{"location":"Pages/state_machine/subsystems_state_machine/#commands-folder","title":"Commands Folder","text":"<p>The <code>commands</code> folder holds commands that are responsible for runing the subsystems. Each file implements the <code>SubsystemCommand</code> interface for that subsystem.</p>"},{"location":"Pages/state_machine/subsystems_state_machine/#folder-example","title":"Folder Example:","text":"<pre><code>/robot/Commands/\n  \u251c\u2500\u2500 IntakeCommand.java\n  \u251c\u2500\u2500 ArmCommand.java\n</code></pre>"}]}