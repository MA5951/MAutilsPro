{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"Pages/","title":"Welcome to MAutils","text":"<p>MAutils is a powerful, modular Java library designed to streamline FRC robot development. Built with performance, flexibility, and ease of use in mind, it offers a wide range of features including: <ul> <li>An intuitive state machine system  </li> <li>Robot-wide logging and Dashboard intigration</li> <li>Fuully featured swerve code  </li> <li>Default self-testing subsystems </li> <li>...and much more!</li> </ul> <p>MAutils Pro reduces boilerplate and promotes clean, scalable design\u2014helping teams focus more on strategy and performance than repetitive implementation details.</p>"},{"location":"Pages/controllers/","title":"Controller Support in MAutils","text":"<p>MAutils provides a unified and abstracted interface for game controllers, allowing seamless integration with multiple types of gamepads (e.g. PS5 and Xbox) without changing your robot control code.</p> <p>All controllers extend the <code>MAController</code> abstract class, which defines a consistent set of button mappings and input methods.</p>"},{"location":"Pages/controllers/#supported-controllers","title":"Supported Controllers","text":"<ul> <li>PS5 DualSense \u2013 <code>PS5MAController</code></li> <li>Xbox Series Controller \u2013 <code>XboxMAController</code></li> </ul> <p>Both use the same interface:</p> <pre><code>MAController controller = new PS5MAController(0);\n// Or:\ncontroller = new XboxMAController(0);\n</code></pre>"},{"location":"Pages/controllers/#button-layout-unified-naming","title":"Button Layout (Unified Naming)","text":"<p>MAutils uses generic method names so your robot code works consistently across all supported controllers.</p> PS5Xbox <p></p> <p></p> <p>Example:</p> <pre><code>controller.getActionsUp(); // Maps to the Triangle button on PS5 or the Y button on Xbox\n</code></pre>"},{"location":"Pages/controllers/#deadband-handling","title":"Deadband Handling","text":"<p>Each controller has a calibrated deadband value to help eliminate small input noise:</p> Controller Default Deadband PS5 <code>0.1</code> Xbox <code>0.3</code> <p>To apply deadband filtering:</p> <pre><code>double value = controller.withDeadbound(rawValue);         // Uses default for controller\ndouble custom = controller.withDeadbound(rawValue, 0.2);   // Uses custom value\n</code></pre> <p>This can be applied to stick positions or trigger axes as needed.</p>"},{"location":"Pages/controllers/#rumble-support","title":"Rumble Support","text":"<p>The <code>setRumble()</code> method allows vibration feedback, but note:</p> <ul> <li>Xbox controllers support rumble natively through the Driver Station.</li> <li>PS5 controllers do not support rumble reliably unless emulated as Xbox controllers, which is not recommended due to inconsistent behavior.</li> </ul> <pre><code>controller.setRumble(0.5); // Activate rumble at 50% power\n</code></pre>"},{"location":"Pages/controllers/#controller-logging","title":"Controller Logging","text":"<p>For diagnostics or special use cases, you can log controller input to NetworkTables:</p> <pre><code>controller.log();\n</code></pre> <p>This records the current state of buttons and axes to:</p> <pre><code>/Controllers/{port}/[ButtonName]\n</code></pre> <p>Useful for testing in Shuffleboard or AdvantageScope.</p>"},{"location":"Pages/controllers/#sample-implementation","title":"Sample Implementation","text":"<pre><code>@Override\npublic void teleopPeriodic() {\n    if (controller.getL1()) intake.run();\n    if (controller.getR2()) shooter.shoot();\n\n    drivetrain.arcadeDrive(\n        controller.withDeadbound(controller.getLeftY()),\n        controller.withDeadbound(controller.getRightX())\n    );\n\n    controller.log();\n}\n</code></pre>"},{"location":"Pages/key_features/","title":"\ud83c\udfaf Here are some of MAutils Key Features","text":""},{"location":"Pages/key_features/#flexible-state-machine-architecture","title":"\ud83e\udde0 Flexible State Machine Architecture","text":"<ul> <li>Coordinate multiple subsystems easily  </li> <li>Easy to use, debug, and write </li> <li>Perfect for autonomous or multi-stage tasks</li> </ul>"},{"location":"Pages/key_features/#default-subsystems-with-zero-code-setup","title":"\u2699\ufe0f Default Subsystems with Zero Code Setup","text":"<ul> <li>Advanced, configurable subsystems with Zero Code Setup</li> <li>Built-in self-tests and diagnostics  </li> <li>Automatic failure detection </li> </ul>"},{"location":"Pages/key_features/#fully-featured-plug-and-play-swerve-support","title":"\u2705 Fully Featured, Plug-and-Play Swerve Support","text":"<ul> <li>High-frequency odometry updates  </li> <li>Skid and collision detection  </li> <li>Full simulation support via MapleSim</li> <li>PathPlanner integration  </li> <li>Sevral Control modes:  Auto-align, Angle adjust, Advanced Field-relative and Robot-relative drive, and so much more</li> </ul>"},{"location":"Pages/key_features/#comprehensive-logging-system","title":"\ud83e\udeb5 Comprehensive Logging System","text":"<ul> <li>Log values, events, and system health  </li> <li>Useful for both live debugging and post-match analysis</li> </ul>"},{"location":"Pages/key_features/#dashboard-integration","title":"\ud83d\udcca Dashboard Integration","text":"<ul> <li>Tune constants (e.g. PID) in real time  </li> <li>Advanced Auto Ruutine Chooser</li> <li>Works with Elastic FRC Dashboard, Shuffleboard, and more</li> </ul>"},{"location":"Pages/logger/","title":"MALog Logging System","text":"<p>MALog is the unified logging utility in MAutils. It provides an interface for real-time logging to NetworkTables, as well as persistent storage via DataLogManager.</p> <p>The logger records all NetworkTables data, including values logged via MALog, joystick states, vision coprocessor output, and FMS data.</p>"},{"location":"Pages/logger/#initialization","title":"Initialization","text":"<p>Start the logger once at the beginning of a mode:</p> <pre><code>MALog.startLog(MALogMode.AUTO);\n// Or:\nMALog.startLog(MALogMode.TELEOP);\n</code></pre> <p>This starts data logging with a unique session ID and a timestamped filename (if not running on FMS). If using <code>DeafultRobotContainer</code>, the log is started and stopped automaticly.</p> Log naming format <p>Logs are saved using the format: <code>MALog_Mode_SessionID_Timestamp</code>. - Mode corresponds to the robot's current mode (<code>AUTO</code>, <code>TELEOP</code>, <code>TEST</code>). - SessionID is a unique, persistent number that increments on each run (stored in <code>/home/lvuser/malog/lastLogID.txt</code>). Use <code>resetID()</code> to reset it manually. - Timestamp follows the format <code>yyyy-MM-dd_HH-mm-ss</code>.</p> <p>Example: <pre><code>MALog_Teleop_0047_2025-11-02_16-22-17\n</code></pre></p> <p>To stop logging:</p> <pre><code>MALog.stopLog();\n</code></pre>"},{"location":"Pages/logger/#logging-basic-values","title":"Logging Basic Values","text":"<p>You can log values using a string key:</p> <pre><code>MALog.log(\"/Subsystems/Arm/Arm Angle\", 45.0);\nMALog.log(\"/Subsystems/Swerve/Is Aligned\", true);\nMALog.log(\"/RobotControl/Mode\", \"AUTO\");\n</code></pre> <p>Or with suppliers (evaluated at runtime):</p> <pre><code>MALog.log(\"/Pneumatics/Pressure\", () -&gt; compressor.getPressure());\n</code></pre>"},{"location":"Pages/logger/#logging-advanced-types","title":"Logging Advanced Types","text":""},{"location":"Pages/logger/#pose2d","title":"Pose2d","text":"<pre><code>MALog.log(\"Odometry/Pose2d\", drivetrain.getPose());\n</code></pre>"},{"location":"Pages/logger/#pose3d","title":"Pose3d","text":"<pre><code>MALog.log(\"Odometry/Pose3d\", camera.getPose());\n</code></pre>"},{"location":"Pages/logger/#pose3d_1","title":"Pose3d[]","text":"<pre><code>MALog.log(\"Vision/Targets\", allDetectedTags);\n</code></pre>"},{"location":"Pages/logger/#swervemodulestate","title":"SwerveModuleState[]","text":"<pre><code>MALog.logSwerveModuleStates(\"Drive/Modules\", swerve.getModuleStates());\n</code></pre>"},{"location":"Pages/logger/#chassisspeeds","title":"ChassisSpeeds","text":"<pre><code>MALog.log(\"Drive/ChassisSpeeds\", kinematics.toChassisSpeeds());\n</code></pre> <p>All of these publish to NetworkTables under the <code>MALog/</code> namespace.</p>"},{"location":"Pages/logger/#getting-logged-values","title":"Getting Logged Values","text":"<p>You can retrieve numeric values from NetworkTables:</p> <pre><code>double shooterRPM = MALog.getEntry(\"Shooter/RPM\").getDouble(0);\n</code></pre>"},{"location":"Pages/logger/#flags-and-status","title":"Flags and Status","text":"<p>Use <code>flag()</code> to mark specific events in logs:</p> <pre><code>MALog.flag(\"Driver Flag\");\n</code></pre> <p>You can view the flag field in a graph to easily locate these events.</p> Using flags during driver practice <p>If the driver encounters a bug or something feels off, they can press a controller button mapped to <code>MALog.flag()</code>. This creates a visible marker in the log, allowing the software team to easily investigate it afterward.</p> <p>Indicates the status of the robot, other parts of MAutils use this field so its mostly reserved for library use.</p> <pre><code>MALog.addStatus(\"Self Testing\");\n</code></pre>"},{"location":"Pages/logger/#example","title":"Example","text":"<pre><code>@Override\npublic void robotInit() {\n    MALog.startLog(MALogMode.TELEOP);\n}\n\n@Override\npublic void teleopPeriodic() {\n    MALog.log(\"Shooter/Velocity\", shooter.getVelocity());\n    MALog.log(\"Drive/Pose2d\", drivetrain.getPose());\n    MALog.log(\"Drive/Modules\", drivetrain.getModuleStates());\n    MALog.log(\"Intake/Pressed\", intakeButton::get);\n}\n</code></pre>"},{"location":"Pages/port_map/","title":"Port Map","text":"<p>The PortMap file centralizes all hardware port assignments across the robot. This makes it easy to manage and configure device ports in one location.</p>"},{"location":"Pages/port_map/#structure","title":"Structure","text":"<p>Each subsystem is given its own nested class inside the <code>PortMap</code>. All fields should be declared <code>public static</code> for easy access throughout the codebase.</p> <p>The <code>PortMap</code> class should extend <code>DefaultPortMap</code>, which automatically sets up support for CAN bus access via:</p> <ul> <li><code>Rio</code> \u2013 The RoboRIO CAN bus</li> <li><code>Canivore</code> \u2013 The CTRE CANivore bus (if connected)</li> </ul>"},{"location":"Pages/port_map/#can-device-ids","title":"CAN Device IDs","text":"<p>To represent devices on the CAN bus, use the <code>CANBusID</code> class:</p> <pre><code>public CANBusID(int id, CANBus bus)\n</code></pre> <ul> <li><code>id</code>: the device ID on the bus</li> <li><code>bus</code>: the <code>CANBus</code> instance (e.g. <code>Rio</code> or <code>Canivore</code>)</li> </ul>"},{"location":"Pages/port_map/#swerve-module-ids","title":"Swerve Module IDs","text":"<p>For organizing swerve modules, use the <code>SwerveModuleID</code> class:</p> <pre><code>public SwerveModuleID(CANBusID driveMotor, CANBusID steerMotor, CANBusID steerEncoder)\n</code></pre> <p>This bundles the three components of each swerve module. Store them in a <code>SwerveModuleID[]</code> array.</p>"},{"location":"Pages/port_map/#other-device-ports","title":"Other Device Ports","text":"<p>For other devices (DIO, Analog, PWM), use <code>int</code> or the appropriate type.</p>"},{"location":"Pages/port_map/#example-portmap","title":"Example PortMap","text":"<pre><code>public class PortMap extends DefaultPortMap {\n\n    public static class Swerve {\n\n        private static final CANBusID LEFT_FRONT_ENCODER = new CANBusID(22, Canivore);\n        private static final CANBusID LEFT_FRONT_DRIVE = new CANBusID(8, Canivore);\n        private static final CANBusID LEFT_FRONT_TURNING = new CANBusID(5, Canivore);\n\n        private static final CANBusID LEFT_BACK_ENCODER = new CANBusID(21, Canivore);\n        private static final CANBusID LEFT_BACK_DRIVE = new CANBusID(4, Canivore);\n        private static final CANBusID LEFT_BACK_TURNING = new CANBusID(9, Canivore);\n\n        private static final CANBusID RIGHT_FRONT_ENCODER = new CANBusID(23, Canivore);\n        private static final CANBusID RIGHT_FRONT_DRIVE = new CANBusID(7, Canivore);\n        private static final CANBusID RIGHT_FRONT_TURNING = new CANBusID(6, Canivore);\n\n        private static final CANBusID RIGHT_BACK_ENCODER = new CANBusID(24, Canivore);\n        private static final CANBusID RIGHT_BACK_DRIVE = new CANBusID(2, Canivore);\n        private static final CANBusID RIGHT_BACK_TURNING = new CANBusID(3, Canivore);\n\n        public static final CANBusID PIGEON2 = new CANBusID(12, Canivore);\n\n        public static final SwerveModuleID[] SWERVE_MODULE_IDS = {\n            new SwerveModuleID(LEFT_FRONT_ENCODER, LEFT_FRONT_DRIVE, LEFT_FRONT_TURNING),\n            new SwerveModuleID(LEFT_BACK_ENCODER, LEFT_BACK_DRIVE, LEFT_BACK_TURNING),\n            new SwerveModuleID(RIGHT_FRONT_ENCODER, RIGHT_FRONT_DRIVE, RIGHT_FRONT_TURNING),\n            new SwerveModuleID(RIGHT_BACK_ENCODER, RIGHT_BACK_DRIVE, RIGHT_BACK_TURNING)\n        };\n    }\n\n    public static class Arm {\n        public static final CANBusID ARM_MOTOR = new CANBusID(26, Canivore);\n        public static final CANBusID ARM_ENCODER = new CANBusID(27, Canivore);\n        public static final int MAX_LIMIT_SWITCH = 3;\n    }\n\n    public static class Intake {\n        public static final CANBusID INTAKE_LEFT = new CANBusID(29, Canivore);\n        public static final CANBusID INTAKE_RIGHT = new CANBusID(30, Canivore);\n        public static final int FRONT_BEAM_BRAKE = 4;\n        public static final int REAR_BEAM_BRAKE = 5;\n    }\n}\n</code></pre>"},{"location":"Pages/sensors/","title":"Sensor Simulation Wrapper","text":"<p>MAutils provides the <code>SensorSimWrapper</code> class to make sensor simulation seamless and clean. It allows you to inject data into sensors during simulation, while preserving normal behavior on a real robot.</p>"},{"location":"Pages/sensors/#overview","title":"Overview","text":"<p>The <code>SensorSimWrapper</code> class wraps a sensor's data source and lets you override that data while in simulation.</p> <p>It is a generic class (<code>&lt;T&gt;</code>), making it compatible with any data type such as:</p> <ul> <li><code>Boolean</code> (e.g. DIO switches)</li> <li><code>Double</code> (e.g. encoders, IMUs)</li> <li>Custom sensor types</li> </ul>"},{"location":"Pages/sensors/#constructor","title":"Constructor","text":"<pre><code>public SensorSimWrapper&lt;T&gt;(Supplier&lt;T&gt; sensorData);\n</code></pre> <p>This sets the default data source. For example, wrapping a limit switch:</p> <pre><code>DigitalInput limitSwitch = new DigitalInput(0);\nSensorSimWrapper&lt;Boolean&gt; limitSwitchSim = new SensorSimWrapper&lt;&gt;(() -&gt; limitSwitch.get());\n</code></pre>"},{"location":"Pages/sensors/#methods","title":"Methods","text":""},{"location":"Pages/sensors/#setsimsuppliersuppliert-sensorsimsupplier","title":"<code>setSimSupplier(Supplier&lt;T&gt; sensorSimSupplier)</code>","text":"<p>Defines the simulation supplier. This is only used during simulation and provides dynamic sensor behavior.</p>"},{"location":"Pages/sensors/#setvaluet-value","title":"<code>setValue(T value)</code>","text":"<p>Force-sets a value to be returned during simulation, overriding the sim supplier. Useful for precise test cases.</p>"},{"location":"Pages/sensors/#usesupplier","title":"<code>useSupplier()</code>","text":"<p>Restores the sim supplier as the active data source, stopping the override.</p>"},{"location":"Pages/sensors/#getvalue","title":"<code>getValue()</code>","text":"<p>Returns the current value. Automatically returns real sensor data when not in simulation.</p>"},{"location":"Pages/sensors/#example-simulating-an-absolute-encoder","title":"Example: Simulating an Absolute Encoder","text":"<pre><code>public class Arm extends PositionControlledSystem {\n\n    private Encoder absEncoder;\n    private SensorSimWrapper&lt;Double&gt; encoderSim;\n\n    public Arm() {\n        super(\"Arm\", ArmConstants.ARM_CONSTANTS,\n            ArmConstants.IDLE, ArmConstants.UP, ArmConstants.DOWN);\n\n        absEncoder = new Encoder(PortMap.ARM.ABS_ENCODER);\n\n        encoderSim = new SensorSimWrapper&lt;&gt;(() -&gt; absEncoder.get());\n        encoderSim.setSimSupplier(() -&gt; getPosition());\n    }\n\n    public double getAbsAngle() {\n        return encoderSim.getValue();\n    }\n}\n</code></pre> <p>In this example, the absolute encoder is simulated by returning the arm's position when running in simulation.</p>"},{"location":"Pages/state_machine/robot_container_methods/","title":"RobotContainer Overview","text":"<p>The <code>RobotContainer</code> class serves as the main control hub of the robot. It manages critical robot-wide functionality such as the robot state, driver/operator controllers, simulation configuration, and subsystem command coordination.</p>"},{"location":"Pages/state_machine/robot_container_methods/#controller-management","title":"Controller Management","text":"<p>The <code>RobotContainer</code> defines default controllers:</p> <ul> <li><code>driverController</code>: Defaults to a <code>PS5MAController</code> on port <code>0</code></li> <li><code>operatorController</code>: Defaults to a <code>PS5MAController</code> on port <code>1</code></li> </ul> <p>You can customize or override them:</p> <pre><code>setDriverController(new XboxMAController(1));\ngetDriverController();\n\nsetOperatorController(new PS5MAController(3));\ngetOperatorController();\n</code></pre>"},{"location":"Pages/state_machine/robot_container_methods/#simulation-configuration","title":"Simulation Configuration","text":"<p>Simulation tools can be configured using the following methods:</p> <pre><code>setSwerveDriveSimulation(SwerveDriveSimulation simulation);\n</code></pre> <p>Enables drivetrain simulation with MapleSim.</p> <pre><code>setGamePiecesList(new String[] {\"Coral\", \"Algae\"});\n</code></pre> <p>Defines the list of simulated game pieces in MapleSim.</p>"},{"location":"Pages/state_machine/robot_container_methods/#robot-state-management","title":"Robot State Management","text":"<p>The container manages the current and previous <code>RobotState</code>:</p> <pre><code>getRobotState();\ngetLastRobotState();\n\nsetRobotState(RobotState.CLIMB);\n</code></pre> <p>While <code>setRobotState()</code> can be called directly, it is generally managed by triggers and robot logic.</p>"},{"location":"Pages/state_machine/robot_container_methods/#subsystem-coordination","title":"Subsystem Coordination","text":"<p>You can register subsystem commands to be scheduled automatically:</p> <pre><code>addSystemCommand(new ArmCommand());\n</code></pre>"},{"location":"Pages/state_machine/robot_container_methods/#lifecycle-methods","title":"Lifecycle Methods","text":"<p>The <code>RobotContainer</code> also defines lifecycle methods that are called in thier corresponding methods in the <code>Robot</code> class. These calles are are already in place if you generated your project from our template. </p> <ul> <li><code>robotInit()</code></li> <li><code>robotPeriodic()</code></li> <li><code>teleopInit()</code>, <code>teleopPeriodic()</code></li> <li><code>autonomousInit()</code>, <code>autonomousPeriodic()</code></li> <li><code>testInit()</code>, <code>testPeriodic()</code></li> <li><code>simulationInit()</code>, <code>simulationPeriodic()</code></li> </ul>"},{"location":"Pages/state_machine/robot_state/","title":"RobotState Guide","text":"<p>The <code>RobotState</code> class defines the full-state of the robot, encapsulating the intended behavior of all subsystems at a given point in time (e.g. <code>INTAKE</code>, <code>PRE_SCORING</code>, <code>CLIMB</code>).</p>"},{"location":"Pages/state_machine/robot_state/#purpose","title":"Purpose","text":"<p><code>RobotState</code> objects act as high-level modes that:</p> <ul> <li>Assign specific <code>SubsystemState</code>s to each subsystem</li> <li>Optionally run custom logic when the state is entered (e.g. reset counters, print debug messages)</li> </ul>"},{"location":"Pages/state_machine/robot_state/#fields","title":"Fields","text":"<p>Each <code>RobotState</code> contains:</p> <ul> <li><code>name</code> \u2013 A <code>String</code> representing the name of the robot state (e.g. <code>INTAKE</code>, <code>CLIMB</code>)</li> <li><code>subsystemStates</code> \u2013 A collection of the <code>SubsystemState</code>s to be assigned when this state is activated</li> <li><code>onStateSet</code> \u2013 An optional <code>Runnable</code> that executes custom logic (e.g. logging, resetting variables) when the state is set</li> </ul>"},{"location":"Pages/state_machine/robot_state/#state-activation","title":"State Activation","text":"<p>To activate a robot state, call:</p> <pre><code>RobotState.setState();\n</code></pre> <p>This will:</p> <ol> <li>Run the <code>onStateSet</code> Runnable if it exists</li> <li>Set each subsystem's state </li> </ol>"},{"location":"Pages/state_machine/robot_state/#example-definition","title":"Example Definition","text":"<p>Robot states are usually defined in the <code>RobotConstants</code> class for central access:</p> RobotState Names <p>Use descriptive names like <code>PRE_SCORE</code>, <code>CLIMB</code>, or <code>SAFE_DEPLOY</code></p> <pre><code>public class RobotConstants {\n\n    public static final RobotState IDLE = new RobotState(\n        \"IDLE\",\n        IntakeConstants.IDLE,\n        GripperConstants.IDLE,\n        ArmConstants.IDLE,\n        ClimbConstants.IDLE,\n        ElevatorConstants.IDLE\n    );\n\n    public static final RobotState PRE_CLIMB = new RobotState(\n        \"PRE_CLIMB\",\n        () -&gt; { System.out.println(\"PRE_CLIMB Entered\"); },\n        IntakeConstants.IDLE,\n        GripperConstants.IDLE,\n        ArmConstants.CLMB_POS,\n        ClimbConstants.DEPLOY,\n        ElevatorConstants.CLMB_POS\n    );\n\n    public static final RobotState CLIMB = new RobotState(\n        \"CLIMB\",\n        () -&gt; { System.out.println(\"Started Climb\"); },\n        IntakeConstants.IDLE,\n        GripperConstants.IDLE,\n        ArmConstants.CLMB_POS,\n        ClimbConstants.CLIMB,\n        ElevatorConstants.CLMB_POS\n    );\n}\n</code></pre> <p>Each robot state manages the coordination of all major mechanisms for a given scenario.</p>"},{"location":"Pages/state_machine/robot_state_triggers/","title":"Robot State Triggers","text":"<p>Robot state triggers are responsible for changing the current <code>RobotState</code> based on sensor input, subsystem conditions, or driver/operator commands.</p> <p>This system helps manage transitions between complex behaviors (e.g. INTAKE \u2794 IDLE \u2794 SCORING) in a clear and modular way.</p>"},{"location":"Pages/state_machine/robot_state_triggers/#trigger-overview","title":"Trigger Overview","text":"<p>Each <code>RobotState</code> can have:</p> <ul> <li>Enter triggers: Conditions to switch into a state</li> <li>Exit triggers: Conditions to switch out of a state</li> </ul>"},{"location":"Pages/state_machine/robot_state_triggers/#example","title":"Example","text":"<pre><code>// Enter INTAKE state\n!SuperStructure.hasGamePiece() &amp;&amp; getDriverController().getL1()\n\n// Exit INTAKE and enter IDLE when game piece is detected\ngetRobotState() == RobotConstants.INTAKE &amp;&amp; SuperStructure.hasGamePiece()\n</code></pre>"},{"location":"Pages/state_machine/robot_state_triggers/#statetrigger-class","title":"StateTrigger Class","text":"<p>To simplify writing these conditions, MAutils provides the <code>StateTrigger</code> (commonly used via a static function <code>T(...)</code>).</p>"},{"location":"Pages/state_machine/robot_state_triggers/#syntax","title":"Syntax","text":"<pre><code>T(BooleanSupplier condition, RobotState stateToSet).build();\n</code></pre> <p>You can also chain additional context conditions:</p> <pre><code>.withInRobotState(RobotState robotInState)\n.withRobotMode(RobotMode mode)\n</code></pre> <p>These allow a trigger to only apply in specific robot states or match certain robot modes (e.g. TELEOP, AUTO).</p>"},{"location":"Pages/state_machine/robot_state_triggers/#full-example","title":"Full Example","text":"<pre><code>// Transition to INTAKE if we don't have a game piece and L1 is pressed\nT(() -&gt; !SuperStructure.hasGamePiece() &amp;&amp; getDriverController().getL1(), RobotConstants.INTAKE)\n    .build();\n\n// Transition to IDLE once a game piece is acquired (but only if we're currently in INTAKE)\nT(() -&gt; SuperStructure.hasGamePiece(), RobotConstants.IDLE)\n    .withInRobotState(RobotConstants.INTAKE)\n    .build();\n</code></pre>"},{"location":"Pages/state_machine/self_test_subsystem/","title":"Subsystem Self Test Framework","text":"<p>MAutils provides a flexible and efficient framework for building self-testing subsystems. This enables rapid and automated subsystem verification in the pit or during diagnostics.</p> <p>Every <code>StateSubsystem</code> must implement the <code>getSelfTest()</code> function.</p>"},{"location":"Pages/state_machine/self_test_subsystem/#overview","title":"Overview","text":"<p>Each <code>StateSubsystem</code> must implement the following method:</p> <pre><code>Command getSelfTest();\n</code></pre> <p>This method should return a command that executes a series of validation tests.</p>"},{"location":"Pages/state_machine/self_test_subsystem/#test-definition","title":"Test Definition","text":"<p>Tests are encapsulated by the <code>Test</code> class:</p> <pre><code>Test(String name, BooleanSupplier testCondition, Runnable testAction, double timeCap)\n</code></pre> <p>Each <code>Test</code> includes:</p> <ul> <li><code>testName</code>: A human-readable name</li> <li><code>testCondition</code>: Logic that determines pass/fail</li> <li><code>testAction</code>: What to do during the test</li> <li><code>testTimeCap</code>: Timeout in seconds for the condition to pass</li> </ul>"},{"location":"Pages/state_machine/self_test_subsystem/#constructing-a-self-test","title":"Constructing a Self Test","text":"<p>To define a self test, instantiate a <code>SelfSystemTest</code> and chain calls to <code>addTest()</code>:</p> <pre><code>public Command getSelfTest() {\n    return selfSystemTest\n        .addTest(new Test(\"Encoder Sync\", () -&gt; Math.abs(getPosition() - getAbsolutePosition()) &lt;= 2, () -&gt; setVoltage(0.5), 0.5))\n        .addTest(new Test(\"Max Position\", () -&gt; getPosition() &gt; MAX_POS - 2, () -&gt; setPosition(MAX_POS), 0.8))\n        .addTest(new Test(\"Min Position\", () -&gt; getPosition() &lt; MIN_POS + 2, () -&gt; setPosition(MIN_POS), 0.8))\n        .createCommand();\n}\n</code></pre> <p>Each test runs sequentially, evaluating the condition within the allowed time.</p>"},{"location":"Pages/state_machine/self_test_subsystem/#telemetry","title":"Telemetry","text":"<p>Telemetry is automatically published to NetworkTables:</p> <pre><code>/Subsystem/&lt;SubsystemName&gt;/SelfTest/\n</code></pre>"},{"location":"Pages/state_machine/self_test_subsystem/#self-test-status","title":"Self Test Status","text":"<ul> <li><code>\"Starting Self Test For &lt;SubsystemName&gt;\"</code></li> <li><code>\"Passed, Finished Self Test For &lt;SubsystemName&gt;\"</code></li> <li><code>\"Failed, Finished Self Test For &lt;SubsystemName&gt;\"</code></li> </ul>"},{"location":"Pages/state_machine/self_test_subsystem/#test-status","title":"Test Status","text":"<p>For each individual test:</p> <ul> <li><code>\"Running test: &lt;TestName&gt;\"</code></li> <li><code>\"Test timed out: &lt;TestName&gt;\"</code></li> <li><code>\"Test passed: &lt;TestName&gt;\"</code></li> <li><code>\"Test finished: &lt;TestName&gt;\"</code></li> </ul>"},{"location":"Pages/state_machine/state_machine_structure.md/","title":"State Machine Structure","text":"<p>MAutils provides an advanced, flexible, and easy-to-use state machine structure designed to manage robot behavior at both the subsystem and full-system levels.</p> <p>This architecture is built around clear modular components:</p>"},{"location":"Pages/state_machine/state_machine_structure.md/#flow-diagram","title":"Flow Diagram","text":"<pre><code>graph LR\n  A[Driver Inputs, Sensors, Odometry Data, Vision Data ...] --&gt; B[StateTriggers, Decide the current RobotState based on the data];\n  B --&gt; C[RobotState sets all of the subsystems to thier matching SubsystemStates];\n  C --&gt; D[StateSubsystem, holds the system's current SubsystemStates, Calculates CAN_MOVE and decides SystemMode based on inputs ];\n  A --&gt; D;\n  D --&gt; E[SystemCommand, runs the system based on its current SubsystemState, CAN_MOVE and SystemMode];</code></pre>"},{"location":"Pages/state_machine/state_machine_structure.md/#key-components","title":"Key Components","text":""},{"location":"Pages/state_machine/state_machine_structure.md/#robotcontainer-extends-defaultrobotcontainer","title":"<code>RobotContainer</code> (extends <code>DefaultRobotContainer</code>)","text":"<ul> <li>Central brain for the robot.</li> <li>Manages the current <code>RobotState</code>.</li> <li>Handles:<ul> <li>State transitions and logic (StateTriggers)</li> <li>Controllers input</li> <li>Logging setup</li> <li>Simulation configuration </li> </ul> </li> </ul>"},{"location":"Pages/state_machine/state_machine_structure.md/#subsystem-extends-statesubsystem-or-one-of-the-defaultsubsystems","title":"<code>Subsystem</code> (extends <code>StateSubsystem</code> or one of the <code>DefaultSubsystems</code>)","text":"<ul> <li>Encapsulates the physical behavior and control logic for a single subsystem (e.g. Arm, Shooter, Intake).</li> <li>Responsible for:<ul> <li>Holding the current <code>SubsystemState</code> of the system</li> <li>Holding the current <code>SystemMode</code> (e.g. MANUAL, AUTOMATIC)</li> <li>Handling data logging, health checks, and CAN_MOVE logic</li> <li>Configuring and runing Self Tests</li> </ul> </li> </ul>"},{"location":"Pages/state_machine/state_machine_structure.md/#subsystemcommand-extends-subsystemcommand","title":"<code>SubsystemCommand</code> (extends <code>SubsystemCommand</code>)","text":"<ul> <li>A command responsible for running the subsystem based on its <code>SubsystemState</code>, <code>SystemMode</code> and <code>CAN_MOVE()</code></li> <li>Defines:<ul> <li>What the subsystem should do in each of its states</li> <li>What happens in manual mode</li> <li>What happens when movement is disabled</li> </ul> </li> </ul>"},{"location":"Pages/state_machine/state_machine_structure.md/#subsystemstate","title":"<code>SubsystemState</code>","text":"<ul> <li>Represents a specific state for a single subsystem.</li> <li>Assigned to a <code>StateSubsystem</code></li> <li>Can be reused across multiple robot states</li> </ul>"},{"location":"Pages/state_machine/state_machine_structure.md/#robotstate","title":"<code>RobotState</code>","text":"<ul> <li>Represents the state of the full robot.</li> <li>Holds a <code>SubsystemState</code> for each subsystem.</li> </ul>"},{"location":"Pages/state_machine/state_subsystems/","title":"StateSubsystem Overview","text":"<p><code>StateSubsystem</code> is a base class in MAutils designed to represent robot subsystems that operate in distinct states. It simplifies state-based control logic by associating the subsystem with a <code>SubsystemState</code> and <code>SystemMode</code>, and logs system behavior through MALog.</p>"},{"location":"Pages/state_machine/state_subsystems/#constructor","title":"Constructor","text":"<pre><code>public StateSubsystem(String name, SubsystemState... subsystemStates)\n</code></pre> <ul> <li>name \u2013 A unique name for this subsystem (used in logging)</li> <li>subsystemStates \u2013 The set of states this subsystem can operate in; each state is initialized with a reference to this subsystem</li> </ul>"},{"location":"Pages/state_machine/state_subsystems/#fields-and-structure","title":"Fields and Structure","text":"<p>Each <code>StateSubsystem</code> includes the following fields:</p> <ul> <li><code>SubsystemState currentState</code> \u2013 The current state of the subsystem</li> <li><code>SystemMode systemMode</code> \u2013 The system control mode (<code>AUTOMATIC</code>, <code>MANUAL</code>, etc.)</li> <li><code>String subsystemName</code> \u2013 A unique name for this subsystem, used in logging and dashboards</li> </ul>"},{"location":"Pages/state_machine/state_subsystems/#core-methods","title":"Core Methods","text":"<p>These are the primary control methods available in a <code>StateSubsystem</code>:</p> <ul> <li> <p><code>setState(SubsystemState state)</code>   Sets the subsystem\u2019s current state.</p> </li> <li> <p><code>getCurrentState()</code>   Returns the currently active <code>SubsystemState</code>.</p> </li> <li> <p><code>setSystemMode(SystemMode mode)</code>   Sets the system's operational mode.</p> </li> <li> <p><code>getSystemMode()</code>   Returns the current <code>SystemMode</code>.</p> </li> <li> <p><code>CAN_MOVE()</code>   Returns <code>true</code> or <code>false</code> based on whether the subsystem is allowed to operate. Override this in your subclass to implement custom logic.</p> </li> <li> <p><code>getSelfTest()</code>   Returns a <code>Command</code> that runs a self-test. This is intended to be overridden in each subsystem to provide meaningful diagnostics. See the SelfTest documentation for more details.</p> </li> <li> <p><code>periodic()</code>   Called once per scheduler loop. This method includes automatic logging of the subsystem state.</p> </li> </ul> Default Logging Behavior <p>The following values are automatically logged every cycle to NetworkTables:</p> <pre><code>- `/RobotControl/{subsystemName}/Current State`\n- `/RobotControl/{subsystemName}/System Function State`\n- `/RobotControl/{subsystemName}/Can Move`\n</code></pre>"},{"location":"Pages/state_machine/state_subsystems/#instantiating-a-statesubsystem","title":"Instantiating a StateSubsystem","text":"<p>When constructing your <code>StateSubsystem</code>, you must provide a name and optionally pass in all the states the subsystem can use. Each state will automatically link back to this subsystem.</p> <pre><code>public class Arm extends StateSubsystem {\n\n    public Arm() {\n        super(\"Arm\",\n            ArmConstants.IDLE,\n            ArmConstants.INTAKE,\n            ArmConstants.EXTENDED,\n            ArmConstants.RETRACTED,\n            ArmConstants.FEEDER\n        );\n    }\n}\n</code></pre> <p>This design ensures all your subsystem states are registered correctly and the name is consistent across logs and NT entries.</p>"},{"location":"Pages/state_machine/subsystem_command/","title":"Subsystem Command","text":"<p>The <code>SubsystemCommand</code> defines the behavior of a subsystem in different operational scenarios. It centralizes logic for automatic control, manual override, and safety conditions when the subsystem cannot move.</p> <p>This pattern ensures each subsystem consistently follows its intended behavior without duplicating control logic across robot states.</p>"},{"location":"Pages/state_machine/subsystem_command/#command-structure","title":"Command Structure","text":"<p>Each <code>SubsystemCommand</code> must implement the following three methods:</p>"},{"location":"Pages/state_machine/subsystem_command/#1-automatic","title":"1. <code>Automatic()</code>","text":"<p>Handles autonomous and automatic robot modes. Typically structured with a switch statement based on the current state:</p> <pre><code>public void Automatic() {\n    switch (arm.getCurrentState().stateName) {\n        case \"IDLE\":\n            arm.setVoltage(arm.getFeedForward());\n            break;\n        case \"INTAKE\":\n            arm.setPosition(ArmConstants.INTAKE_POS);\n            break;\n        case \"SCORING \":\n            arm.setPosition(SuperStructure.getScoringLevel().getArmPos());\n            break;\n        case \"BALL_ANGLE\":\n            arm.setPosition(SuperStructure.getBallRemovingLevel().getArmPos());\n            break;\n    }\n}\n</code></pre>"},{"location":"Pages/state_machine/subsystem_command/#2-manual","title":"2. <code>Manual()</code>","text":"<p>Typically used to apply input from the operator controller:</p> <pre><code>public void Manual() {\n    arm.setVoltage(\n        RobotContainer.getOperatorController().getLeftY() * ArmConstants.MANUAL_VOLTAGE_LIMIT\n    );\n}\n</code></pre>"},{"location":"Pages/state_machine/subsystem_command/#3-cantmove","title":"3. <code>CantMove()</code>","text":"<p>Called when <code>CAN_MOVE()</code> returns <code>false</code>. This prevents unsafe movement:</p> <pre><code>public void CantMove() {\n    arm.setVoltage(arm.getFeedForward());\n}\n</code></pre> <p>In most systems, this simply applies a feedforward hold or zero voltage.</p>"},{"location":"Pages/state_machine/subsystem_command/#example-full-armcommand","title":"Example: Full ArmCommand","text":"<pre><code>package frc.robot.commands;\n\nimport com.MAutils.RobotControl.SubsystemCommand;\n\nimport frc.robot.RobotContainer;\nimport frc.robot.subsystems.Arm.Arm;\n\npublic class ArmCommand extends SubsystemCommand {\n    private static Arm arm = RobotContainer.arm;\n\n    public ArmCommand() {\n        super(arm);\n    }\n\n    public void Automatic() {\n    switch (arm.getCurrentState().stateName) {\n        case \"IDLE\":\n            arm.setVoltage(arm.getFeedForward());\n            break;\n        case \"INTAKE\":\n            arm.setPosition(ArmConstants.INTAKE_POS);\n            break;\n        case \"SCORING \":\n            arm.setPosition(SuperStructure.getScoringLevel().getArmPos());\n            break;\n        case \"BALL_ANGLE\":\n            arm.setPosition(SuperStructure.getBallRemovingLevel().getArmPos());\n            break;\n        }\n    }\n\n    public void Manual() {\n        arm.setVoltage(\n            RobotContainer.getOperatorController().getLeftY() * ArmConstants.MANUAL_VOLTAGE_LIMIT);\n    }\n\n    public void CantMove() {\n        arm.setVoltage(arm.getFeedForward());\n    }\n}\n</code></pre>"},{"location":"Pages/state_machine/subsystem_command/#autonomous-and-test-modes","title":"Autonomous and Test Modes","text":"<ul> <li> <p>Autonomous:  By default, the command executes the Automatic() method during autonomous mode. You can override this  method if you require a different behavior in auto.</p> </li> <li> <p>Test: In test mode, no logic is run by default. This prevents interference with any self-test commands being executed. You may override this behavior by defining a custom Test() method in your command if needed.</p> </li> </ul>"},{"location":"Pages/state_machine/subsystem_logic/","title":"Subsystem Logic: <code>CAN_MOVE()</code>","text":"<p>Each <code>StateSubsystem</code> in MAutils must implement the <code>CAN_MOVE()</code> method to define whether the system is currently allowed to move. This mechanism is essential for safe coordination between multiple subsystems and simplifies complex inter-subsystem logic.</p>"},{"location":"Pages/state_machine/subsystem_logic/#purpose-of-can_move","title":"Purpose of <code>CAN_MOVE()</code>","text":"<p>The <code>CAN_MOVE()</code> method returns a boolean that indicates whether the subsystem can safely perform movement-related actions.</p> <p>It is used to:</p> <ul> <li>Prevent collisions between subsystems</li> <li>Coordinate manipulator safety (e.g., arm and elevator)</li> <li>Respect physical limits (e.g., soft stops, mechanical ranges)</li> <li>Detect fault states like high current draw</li> </ul> <p>Always tailor <code>CAN_MOVE()</code> to the specific logic and safety requirements of each subsystem.</p>"},{"location":"Pages/state_machine/subsystem_logic/#recommended-use-cases","title":"Recommended Use Cases","text":""},{"location":"Pages/state_machine/subsystem_logic/#collision-avoidance","title":"Collision Avoidance","text":"<p>Check that your subsystem won\u2019t collide with another.</p>"},{"location":"Pages/state_machine/subsystem_logic/#game-piece-safety","title":"Game Piece Safety","text":"<p>Ensure game pieces are secured or released only under valid conditions.</p>"},{"location":"Pages/state_machine/subsystem_logic/#spatial-boundaries","title":"Spatial Boundaries","text":"<p>Avoid exceeding minimum or maximum mechanical limits.</p>"},{"location":"Pages/state_machine/subsystem_logic/#current-monitoring","title":"Current Monitoring","text":"<p>Stop motion if current indicates a jam or stall.</p>"},{"location":"Pages/state_machine/subsystem_logic/#recommended-pattern-for-manipulator-subsystems","title":"Recommended Pattern for Manipulator Subsystems","text":"<p>For systems like intakes, grippers, shooters, or transfers, we recommend having per-robot-state checks:</p> <pre><code>public boolean IntakeCanMove() {\n    return RobotContainer.getRobotState() == RobotConstants.INTAKE\n        &amp;&amp; Elevator.atPoint()\n        &amp;&amp; Arm.atPoint()\n        &amp;&amp; !gamePieceSensor.get();\n}\n\npublic boolean ScoringCanMove() {\n    return RobotContainer.getRobotState() == RobotConstants.SCORING\n        &amp;&amp; Elevator.atPoint()\n        &amp;&amp; Arm.atPoint()\n        &amp;&amp; gamePieceSensor.get()\n        &amp;&amp; Swerve.atPosition();\n}\n\n@Override\npublic boolean CAN_MOVE() {\n    return IntakeCanMove() || ScoringCanMove();\n}\n</code></pre> <p>This pattern ensures each robot state has its own movement condition logic, improving clarity and safety.</p>"},{"location":"Pages/state_machine/subsystem_logic/#example-for-motion-constraints-elevator-arm-etc","title":"Example for Motion Constraints (Elevator, Arm, etc.)","text":"<p>For subsystems that move within physical bounds:</p> <pre><code>@Override\npublic boolean CAN_MOVE() {\n    return getPosition() &lt; ElevatorConstants.MAX_POSE\n        &amp;&amp; getPosition() &gt; ElevatorConstants.MIN_POSE\n        &amp;&amp; Math.abs(getCurrent()) &lt; 60;\n}\n</code></pre> <p>This prevents damage from over-extension and detects jams based on current draw.</p>"},{"location":"Pages/state_machine/subsystem_states/","title":"SubsystemState","text":"<p>The <code>SubsystemState</code> class represents a specific state of a given subsystem.</p>"},{"location":"Pages/state_machine/subsystem_states/#structure","title":"Structure","text":"<p>Each subsystem has its own collection of <code>SubsystemState</code> objects, which are linked to the subsystem they belong to.</p> <p>Every <code>SubsystemState</code> contains:</p> <ul> <li><code>stateName</code> \u2014 The name of the state.</li> <li><code>subsystem</code> \u2014 The <code>StateSubsystem</code> it is assigned to.</li> </ul> <p>A <code>SubsystemState</code> can be created in two ways:</p> <pre><code>public static final SubsystemState PRE_SCORING = new SubsystemState(\"PRE_SCORING\", arm);\n</code></pre> <p>or by assigning the subsystem later:</p> <pre><code>public static final SubsystemState PRE_SCORING = new SubsystemState(\"PRE_SCORING\");\nPRE_SCORING.setSubsystem(arm);\n</code></pre> <p>\u26a0\ufe0f Warning: Always ensure the <code>stateName</code> matches the variable name. This ensures consistency and improves readability when debugging or logging.</p> SubsystemState Names <p>We recommand to name your subsystem states based on the robot state they will be used on or a descriptive actions, for example \"INTAKE\" \"PRE_SCORING\" \"DEPLOY_CLIMB\" \"CLOSE_CLIMB\" and so on!</p>"},{"location":"Pages/state_machine/subsystem_states/#recommended-usage","title":"Recommended Usage","text":"<p>It is recommended to define all your states in a constants file like this:</p> <pre><code>public class ArmConstants {\n    //Other Constants...\n\n    public static final SubsystemState IDLE = new SubsystemState(\"IDLE\");\n    public static final SubsystemState INTAKE = new SubsystemState(\"INTAKE\");\n    public static final SubsystemState L1_SCORING = new SubsystemState(\"L1_SCORING\");\n    public static final SubsystemState PRE_SCORING = new SubsystemState(\"PRE_SCORING\");\n}\n</code></pre> <p>Then, pass those states into the <code>StateSubsystem</code> constructor to automatically bind them to the subsystem:</p> <pre><code>public class Arm extends StateSubsystem {\n    public Arm() {\n        super(\"Arm\",\n            ArmConstants.IDLE,\n            ArmConstants.INTAKE,\n            ArmConstants.L1_SCORING,\n            ArmConstants.PRE_SCORING\n        );\n    }\n}\n</code></pre> <p>This makes the state machine setup cleaner and ensures every state knows which subsystem it belongs to.</p>"},{"location":"Pages/state_machine/subsystems_state_machine/","title":"Subsystems Structure","text":""},{"location":"Pages/state_machine/subsystems_state_machine/#file-structure-for-subsystems","title":"File Structure for Subsystems","text":"<p>MAutils encourages a clean, modular folder and file structure to organize subsystem logic, constants, and commands.</p> <p>Each subsystem resides in its own folder and contains two core files:</p> <ul> <li>A main subsystem class (e.g., <code>Intake.java</code>, <code>Arm.java</code>)</li> <li>A constants file (e.g., <code>IntakeConstants.java</code>, <code>GripperConstants.java</code>)</li> <li>A folder that containse IOs and other heleper class (If needed) </li> </ul> <p>This structure makes it easy to locate physical configurations, states, and PID parameters for each component.</p>"},{"location":"Pages/state_machine/subsystems_state_machine/#subsystem-folder-layout","title":"Subsystem Folder Layout","text":"<pre><code>/robot/Subsystems\n  \u2514\u2500\u2500 Intake/\n        \u251c\u2500\u2500 IOs (If needed)\n        |    \u251c\u2500\u2500 IntakeIOReal.java\n             \u2514\u2500\u2500 IntakeIOSim.java\n        \u251c\u2500\u2500 Intake.java\n        \u2514\u2500\u2500 IntakeConstants.java\n\n  \u2514\u2500\u2500 Arm/\n        \u251c\u2500\u2500 Arm.java\n        \u2514\u2500\u2500 ArmConstants.java\n</code></pre>"},{"location":"Pages/state_machine/subsystems_state_machine/#constants-file-purpose","title":"Constants File Purpose","text":"<p>The <code>*Constants.java</code> file should include:</p> <ul> <li>Physical dimensions (gear ratios, encoder ticks, etc.)</li> <li>PID tuning values</li> <li>Static configuration parameters</li> <li>The <code>SubsystemState</code> definitions used by that subsystem</li> </ul> <p>Example (partial):</p> <pre><code>public class ArmConstants {\n    public static final double kP = 0.07;\n    public static final double ARM_LENGTH = 0.48;\n\n    public static final SubsystemState IDLE = new SubsystemState(\"IDLE\");\n    public static final SubsystemState EXTENDED = new SubsystemState(\"EXTENDED\");\n}\n</code></pre>"},{"location":"Pages/state_machine/subsystems_state_machine/#commands-folder","title":"Commands Folder","text":"<p>The <code>commands</code> folder holds commands that are responsible for runing the subsystems. Each file implements the <code>SubsystemCommand</code> interface for that subsystem.</p>"},{"location":"Pages/state_machine/subsystems_state_machine/#folder-example","title":"Folder Example:","text":"<pre><code>/robot/Commands/\n  \u251c\u2500\u2500 IntakeCommand.java\n  \u251c\u2500\u2500 ArmCommand.java\n</code></pre>"},{"location":"Pages/swerve/swerve/","title":"Features And Structure","text":"<p>MAutils provide a fully featured swerve code that includes:</p> <ul> <li>Fully feaatured simulation using maple sim</li> <li>high frequency odometry </li> <li>Path planner intigration</li> <li>Skid and collision det4ection</li> <li>Easy to use, advanced control modes</li> <li>Easy to use and configure deafult code</li> </ul> <p>the swerve structure is the following:</p> <p>the swerve subsystem hhs it own folder in the subsystem folder, </p> <p>in the folder there are two files: SwerveConstants.java -=&gt; Holds constatns fro subsystem Swerve.java -=&gt; Holds Subsystem</p> <p>in the commands folder we will have a Swerve folder, and inseid will be two files  <code>SwerveTeleopController</code> -&gt; controles the swerve in teleop <code>SwerveAutoController</code> -&gt; controls the swerve in auto</p>"},{"location":"Pages/swerve/swerve_control/","title":"Swerve Controller Guide","text":""},{"location":"Pages/swerve/swerve_control/#what-is-a-swerve-controller","title":"What is a Swerve Controller?","text":"<p>A SwerveController takes input data (like joystick positions or sensor values) and converts them into a <code>ChassisSpeeds</code> object.</p> <p>All swerve controllers must extend the abstract <code>SwerveController</code> class and implement the <code>getSpeeds()</code> method.</p> <p>Each controller logs its data to NetworkTables at:</p> <pre><code>/Subsystems/Swerve/Controllers/{Controller Name}/{Data Name}\n</code></pre>"},{"location":"Pages/swerve/swerve_control/#built-in-controllers","title":"Built-In Controllers","text":""},{"location":"Pages/swerve/swerve_control/#fieldcentricdrive","title":"FieldCentricDrive","text":"<ul> <li>Inputs: Driver controller, gyro angle, swerve constants</li> <li>Output: Field-relative <code>ChassisSpeeds</code></li> <li>Example:</li> </ul> <pre><code>FieldCentricDrive fieldCentricDrive = new FieldCentricDrive(driverController, swerveSystem, constants);\nfieldCentricDrive.withReduction(() -&gt; driverController.getR2(), 0.4); // 40% speed when R2 pressed\n.withSclers(1.0, 0.7); // X and Y scaling\n</code></pre>"},{"location":"Pages/swerve/swerve_control/#angleadjustcontroller","title":"AngleAdjustController","text":"<ul> <li> <p>Inputs: Setpoint, current yaw (gyro), PIDController</p> </li> <li> <p>Output: Angular <code>omega</code> control in <code>ChassisSpeeds</code></p> </li> <li> <p>Example:</p> </li> </ul> <pre><code>PIDController angleAdjustPID = new PIDController(0.1, 0, 0);\nangleAdjustPID.enableContinuousInput(180, -180);\n\nAngleAdjustController angleAdjustController = new AngleAdjustController(\n    angleAdjustPID,\n    () -&gt; swerveSystem.getGyroData().yaw\n);\n\nangleAdjustController.withSetPoint(180);\n</code></pre>"},{"location":"Pages/swerve/swerve_control/#xyadjustcontroller","title":"XYAdjustController","text":"<ul> <li>Inputs: XY setpoints and current position, two PIDControllers</li> <li>Output: X and Y velocity control in <code>ChassisSpeeds</code></li> <li>Example:</li> </ul> <pre><code>xyAdjustController\n    .withXYControllers(xPID, yPID)\n    .withXYSuppliers(() -&gt; pose.getX(), () -&gt; pose.getY());\n</code></pre>"},{"location":"Pages/swerve/swerve_control/#create-your-own","title":"Create Your Own","text":"<p>You can implement your own <code>SwerveController</code> by overriding <code>getSpeeds()</code> and logging telemetry for visibility.</p> <p>Your controller can accept any combination of sensors, PID controllers, or input sources.</p>"},{"location":"Pages/swerve/swerve_state/","title":"SwerveState Guide","text":"<p>The <code>SwerveState</code> class represents a defined operational state for a swerve drive. Each state encapsulates the drive commands (chassis speeds) that the robot should use when in that state.</p> <p>This abstraction makes it easier to manage complex behaviors like target locking, predefined trajectories, or driver input modes.</p>"},{"location":"Pages/swerve/swerve_state/#constructor","title":"Constructor","text":"<p>Each state requires a name for logging and identification:</p> <pre><code>SwerveState CORAL_STATION_LOCK = new SwerveState(\"Coral Station Lock\");\n</code></pre>"},{"location":"Pages/swerve/swerve_state/#defining-speeds","title":"Defining Speeds","text":"<p>You can configure how the state determines the robot's movement:</p> <ul> <li><code>withXY(SwerveController controller)</code> \u2013 uses the X and Y speeds from the given controller</li> <li><code>withOmega(SwerveController controller)</code> \u2013 uses the rotational speed (omega) from the controller</li> <li><code>withSpeeds(SwerveController controller)</code> \u2013 uses full chassis speeds from the controller</li> <li><code>withSpeeds(ChassisSpeeds speeds)</code> \u2013 sets constant speeds</li> <li><code>withXY(double x, double y)</code> \u2013 sets constant X and Y speeds</li> <li><code>withOmega(double omega)</code> \u2013 sets a constant rotational speed</li> <li><code>withXY(Supplier&lt;Double&gt; x, Supplier&lt;Double&gt; y)</code> \u2013 sets dynamic X and Y speeds</li> <li><code>withOmega(Supplier&lt;Double&gt; omega)</code> \u2013 sets dynamic rotational speed</li> </ul>"},{"location":"Pages/swerve/swerve_state/#state-entry-and-execution-hooks","title":"State Entry and Execution Hooks","text":"<p>These allow you to run logic when entering or while running a swerve state:</p> <ul> <li><code>withOnStateEnter(Runnable onStateEnter)</code> \u2013 code to run once when the state is entered</li> <li><code>withOnStateRunning(Runnable onStateRunning)</code> \u2013 code to run periodically while in the state</li> </ul> <p>This is useful for Setting setpoints and parameters for controllers</p>"},{"location":"Pages/swerve/swerve_state/#example","title":"Example","text":"<p>Here is a complete example of defining a state that follows driver control for XY movement, but locks the robot's angle toward a target:</p> <pre><code>SwerveState CORAL_STATION_LOCK = new SwerveState(\"Coral Station Lock\");\n\nCORAL_STATION_LOCK\n    .withXY(fieldCentricDrive)\n    .withOmega(angleAdjustController)\n    .withOnStateEnter(() -&gt; angleAdjustController.withSetPoint(SuperStructure.getCoralAngle()));\n</code></pre> <p>This makes the robot follow driver field-centric translation while locking rotation toward a specific target.</p> <pre><code>SwerveState CORAL_STATION_LOCK = new SwerveState(\"Coral Station Lock\");\n\nCORAL_STATION_LOCK\n    .withXY(-1,0)\n    .withOmega(0);\n</code></pre> <p>This makes the robot move at -1 meter per secound in X while 0 in Y and Omega while being in this state.</p> <pre><code>SwerveState CORAL_STATION_LOCK = new SwerveState(\"Coral Station Lock\");\n\nCORAL_STATION_LOCK\n    .withSpeeds(fieldCentricDrive);\n</code></pre> <p>This makes the robot folloe the driver field-centric translation.</p>"}]}